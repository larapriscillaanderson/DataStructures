**Sliding Window Algorithm**

A Sliding Window is a technique used to solve problems involving subarrays, substrings, or contiguous data in an efficient manner. Instead of recalculating results for every possible window in the data, it moves a window over the input to find the desired result in linear time.

The basic idea:

1. Two Pointers: We use two pointers to represent a window. The first pointer marks the start of the window, and the second pointer marks the end.
2. Expand the Window: The window is expanded by moving the right pointer (end) forward.
3. Shrink the Window: The window is contracted by moving the left pointer (start) forward when certain conditions are met.
4. Update as You Go: The key idea is to adjust the window dynamically as you traverse through the input array or string, ensuring optimal performance.

This allows the algorithm to achieve O(n) time complexity for many problems, where n is the size of the input.

**When to Use Sliding Window**

- Problems involving subarrays, substrings, or continuous data.
- Problems that involve finding a maximum or minimum of a subarray, or other conditions like sums, averages, etc.
- Often used in optimization problems where you need to maximize or minimize a condition over a range of data.

**Types of Sliding Window Techniques**

1. Fixed-size Window:
    - The size of the window is pre-determined, and the window slides over the array or string.
    - Example: Maximum sum of a subarray of size k.

2. Dynamic-size Window:
    - The size of the window adjusts dynamically depending on certain conditions.
    - Example: Longest substring without repeating characters.

**LeetCode Problem Examples**

Here are a few problems where the hash map algorithm can be applied:

# placeholder

**Key Modifications Across Problems**

1. Fixed vs Dynamic Window Size

- Some problems require a fixed-size window (e.g., maximum sum of a subarray of size k), while others require a window whose size adjusts based on conditions (e.g., longest substring without repeating characters).

2. Using Hash Maps to Track Elements

- In many sliding window problems (like finding the longest substring without repeating characters), hash maps are used to track element frequencies within the window.

3. Tracking Maximum/Minimum/Count

- Sliding window problems often require you to keep track of the maximum or minimum value within the current window. Efficient tracking can be done with additional data structures like deques or priority queues.

4. Expanding and Contracting the Window

- Expanding the window (by moving the right pointer) and contracting it (by moving the left pointer) based on specific conditions (e.g., exceeding a sum or encountering a duplicate).

**Tips for Using Sliding Window**

✅ Determine if the problem involves a contiguous range of elements: Sliding window works best when the problem revolves around subarrays or substrings.

✅ Track conditions dynamically: As the window expands or contracts, make sure you update the necessary information (e.g., sum, frequency counts, maximum/minimum).

✅ Optimize with hash maps or deques: For problems involving frequency counts or order tracking (like substrings), consider using hash maps, and for tracking max/min values efficiently, consider using deques.

✅ Use a double-pointer approach for efficiency: The two-pointer technique ensures that each element is processed once, achieving O(n) time complexity.
